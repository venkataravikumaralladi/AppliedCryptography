"""
File Created: 6th November 2021
Author: Venkata Ravi K A 
-----

"""

'''
    Notes: 
        One time pad (OTP) requires random bits as key. So we use random module.
        One time pad (OTP): It is unbreakable cipher because it is mathematically proven, but it is not 
        practical to implement. So we use lower end of OTP for example 3DES. 
        
        Stream ciphers are comprimise implementation of OTP. Modern Crpytography basic idea is based
        on XOR function. It has interesting property (message ^ random = cipher) and (cipher ^ random = message).

        The One Time Pad is simply an XOR function. Here security lies in the random key stream. 
        The beauty of OTP is the simplicity and proof that it is information theoretical secure given
        a TRUE random key stream. Requirments that OTP is unbreakable are
            i. key stream only used once.
            ii. key stream is generated by true randomness.

        The security of OTP can be understood as follows
            	Given a cipher text.
            	Guess a plain text of the same length.
            	Then there is a matching key stream that will decrypt the cipher text to that plain text.
            	As any key stream is possible it could be plain text

        OTP is secured because if we guess a message we can generate that random key to get that message
        given cipher text, so all messages are equally likely. So if we decrpyt to any thing then it does
        not matter how much computing power you have because we can never know if it is right one or not.
'''

import random


class OneTimePad:
    '''
    '''
    def __init__(self):
        return
    
    def _generate_random_key(self, size:int):
        '''
        Private function to generate random key

        Parameters
        ----------
        size : int
            length of random key.

        Returns
        -------
        None.

        '''
        self.key =  bytes([random.randrange(0,256) for i in range(size)])
        return
    
    def get_key(self) -> bytes:
        '''
        Returns key used for encryption. This function should be called after encrypt function.

        Returns
        -------
        bytes
            key in bytes stream.

        '''
        return self.key
        
    def encrypt(self, msg_stream:str) -> bytes:
        '''
        Encrypt given message stream with generated random key of given length.

        Parameters
        ----------
        msg_stream : str
            message stream to be encrypted with generated key

        Returns
        -------
        bytes
            encrypted byte stream.

        '''
        # generate random key
        self._generate_random_key(len(msg_stream))
        return bytes(self.key[i] ^ msg_stream[i] for i in range(len(self.key)))
    
    def decrypt(self, cipher_stream:str) -> bytes:
        '''
        Decrypt given cipher stream with key used during encyprtion.

        Parameters
        ----------
        cipher_stream : str
            cipher stream to decrypt to original message using key.

        Returns
        -------
        bytes
            return original message in byte stream.

        '''
        return bytes(self.key[i] ^ cipher_stream[i] for i in range(len(self.key)))
    
    
if __name__ == '__main__':

    otp = OneTimePad()
    message = "YOU ARE GOOD"
    message = message.encode()
    cipher_msg = otp.encrypt(message)
    print('otp key used: ', otp.get_key())
    print('cipher message: ', cipher_msg)
    print('original message after decrypt is: ', otp.decrypt(cipher_msg))
    
    
    